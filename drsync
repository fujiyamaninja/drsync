#!/usr/bin/env bash

# create a variable that contains the entire set of arguments passed as a single line and preserving escape characters
args=""
for arg in "$@"
do
  args+=$(printf '%q ' "$arg")
done
#echo "$args"

# create a hidden logfile directory if there isn't already one
if [ ! -d "$HOME/.drsync_transfers" ] 
then
   mkdir "$HOME/.drsync_transfers"
fi

# figure out a valid transfer number and assign a new session name
prev_transfer_num=`ls "$HOME/.drsync_transfers" | sort --version-sort | grep "drsync" | tail -1 | grep -o "[1-9][0-9]*"`
transfer_num=$((prev_transfer_num+1))
session_name=`printf 'drsync.%06g' "$transfer_num"`
logfile="$HOME/.drsync_transfers/$session_name"

# touch logfile to reserve number in case another job launches before logging starts
touch "$logfile.log"

# parse args to figure out if the transfer is using any --include-from text files, so that we can preserve them alongside the logs
include_from_used='No'
if [[ $args == *"--include-from"* ]]; then
  for var in "$@"
  do
    if [[ $var == *"--include-from"* ]]; then
      include_from=$(echo "$var" | sed 's/--include-from=//')
    fi
  done
  cp "$include_from" "$logfile.includefrom"
  include_from_used='Yes'
  # modify the args passed to screen session to cleanup the include file.
  args=`printf '%s; rm %s' "$args" "$include_from"`
fi

#cludes=()
#if [[ $args == *"--*clude="* ]]; then
#  for var in "$@"
#  do
#    if [[ $args == *"--*clude="* ]]; then
#      cludes+=("$var")
#    fi
#  done
#fi

# parse args to figure out which args are source directories.
sources=()
sources_str=""
for var in ${@:1:$#-1}
do
  [[ $var =~ ^-.* ]] && continue
    sources+=("$var")
    sources_str="$sources_str$var\n"
done

# parse for target
target="${@: -1}"

# if we passed a --remove-source-files, then modify the args to include a bunch of find and delete empties
cleanup='No'
if [[ $args == *"--remove-source-files"* ]]; then
  source_parents=()
  for source in "${sources[@]}"
  do
    source_parent=$(echo "$source" | grep -o '.*/')
    echo "$source_parent"
    source_parents+=("$source_parent")
  done
  uniq_source_parents=($(for p in "${source_parents[@]}"; do echo "${p}"; done | sort -u))
  for p in "$uniq_source_parents"
  do
    args=`printf '%s; find %s -empty -type d -delete' "$args" "$p"`
  done
  echo 'Empty directories left in source directories will be cleaned after rsync is complete.'
  cleanup='Yes'
fi

printf "$sources_str" > "$logfile.sources"
printf "$target" > "$logfile.target"
# launch the screen session with the arguments we passed
screen -dmS "$session_name" bash -c "echo pwd: $PWD; echo Removed and cleaned sources: $cleanup; echo Used --include-from option: $include_from_used; rsync --info=progress2 $args; sleep 3;"

# create a background process that dumps the current screen content to a file for the session so long as the screen exists
(while screen -list | grep -q "$session_name"; do screen -S "$session_name" -X hardcopy "$logfile.log" >/dev/null 2>&1; sleep 1; done) &

# tell the user where to watch the progress output
printf 'Status can be viewed by watching %s\n' "$logfile."
