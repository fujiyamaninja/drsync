#!/usr/bin/env bash

# create a variable that contains the entire set of arguments passed as a single line and preserving escape characters
args=""
for arg in "$@"
do
  args+=$(printf '%q ' "$arg")
done

# create a hidden logfile directory if there isn't already one
if [ ! -d "$HOME/.drsync_transfers" ] 
then
   mkdir "$HOME/.drsync_transfers"
fi

# figure out a valid transfer number and assign a new session name
prev_transfer_num=$(ls "$HOME/.drsync_transfers" | sort --version-sort | grep "drsync.*.cmd" | tail -1 | grep -o "[1-9][0-9]*")
transfer_num=$((prev_transfer_num+1))
session_name=$(printf 'drsync.%06g' "$transfer_num")
logfile="$HOME/.drsync_transfers/$session_name"

# log the command that was used
printf 'drsync %s' "$args" > "$logfile.cmd"

# do a dry run of the rsync job and log the file list
bash -c "rsync -v --dry-run $args > $logfile.filelist"
bash -c "awk -v n=1 -v s='<===================== VERIFY INCREMENTAL FILE LIST =====================>' 'NR == n {print s} {print}' $logfile.filelist | less -S"

# touch logfile to reserve number in case another job launches before logging starts
touch "$logfile.status"

# add to the args to redirect any rsync errors to a file
args=$(printf '%s 2> %s' "$args" "$logfile.err")

# parse args to figure out if the transfer is using any --include-from text files, so that we can preserve them alongside the logs
include_from_used='No'
if [[ $args == *"--include-from"* ]]; then
  for var in "$@"
  do
    if [[ $var == *"--include-from"* ]]; then
      include_from=$(echo "$var" | sed 's/--include-from=//')
    fi
  done
  cat "$include_from" > "$logfile.includefrom"
  include_from_used='Yes'
  # modify the args passed to screen session to cleanup the include file.
  args=$(printf '%s; rm %s 2>> %s' "$args" "$include_from" "$logfile.err")
fi

# parse args to figure out if the transfer is using any --include-from text files, so that we can preserve them alongside the logs
files_from_used='No'
if [[ $args == *"--files-from"* ]]; then
  for var in "$@"
  do
    if [[ $var == *"--files-from"* ]]; then
      files_from=$(echo "$var" | sed 's/--files-from=//')
    fi
  done
  cat "$files_from" > "$logfile.filesfrom"
  files_from_used='Yes'
  # modify the args passed to screen session to cleanup the include file.
  args=$(printf '%s; rm %s 2>> %s' "$args" "$files_from" "$logfile.err")
fi

# parse args to figure out which args are source directories.
sources=()
sources_str=""
sources_print=""
for var in ${@:1:$#-1}
do
  [[ $var =~ ^-.* ]] && continue
    sources+=("$var")
    sources_str="$sources_str$var\n"
    sources_print="$sources_print$var "
done

# parse for target
target="${@: -1}"

# if we passed a --remove-source-files, then modify the args to include a bunch of find and delete empties
cleanup='No'
if [[ $args == *"--remove-source-files"* ]]; then
  cleanup='Yes'
fi

printf "$sources_str" > "$logfile.sources"
printf "$target" > "$logfile.target"

export sources_print
export target
export cleanup
export include_from_used
export files_from_used
export args

function rsyncwrapper {
  start=$(date)
  echo Started: "$start"
  echo pwd: '   ' "$PWD"
  echo Sources: "$sources_print"
  echo Target: '' "$target"
  echo Remove and clean sources: "$cleanup"
  echo Use --include-from option: "$include_from_used"
  echo Use --files-from option: "$files_from_used"
  bash -c "rsync --no-inc-recursive --info=progress2 $args"
  finish=$(date)
  echo Finished: "$finish"
  sleep 3 
}

export -f rsyncwrapper

read  -n 1 -p "Proceed with transfer? (Y/n):" transfer_approved
echo ''
if [ "$transfer_approved" == 'n' ] || [ "$transfer_approved" == 'N' ]; then
  echo 'Transfer aborted.'
  echo 'Transfer aborted.' >> "$logfile.status"
else
  # launch the screen session with the arguments we passed using the wrapper we defined above
  screen -dmS "$session_name" -L -Logfile "$logfile.log" bash -c 'rsyncwrapper'

  # create a background process that dumps the current screen content to a file for the session so long as the screen exists
  (while screen -list | grep -q "$session_name"; do screen -S "$session_name" -X hardcopy "$logfile.status" >/dev/null 2>&1; [ -s "$logfile.err" ] && echo "Error encountered during rsync execution. See $logfile.err" >> "$logfile.status"; sleep 1; done) &
fi

# tell the user where to watch the progress output
echo "Status can be viewed at $logfile.status"

