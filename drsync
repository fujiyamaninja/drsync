#!/usr/bin/env bash

if [ ! -d "$HOME/.drsync_transfers" ] 
then
   mkdir "$HOME/.drsync_transfers"
fi

# figure out a valid transfer number and assign a new session name
prev_transfer_num=`ls "$HOME/.drsync_transfers" | sort --version-sort | grep "drsync" | tail -1 | grep -o "[1-9][0-9]*"`
transfer_num=$((prev_transfer_num+1))
session_name=`printf 'drsync.%06g' "$transfer_num"`
logfile="$HOME/.drsync_transfers/$session_name"

# touch logfile to reserve number in case another job launches before logging starts
touch "$logfile"

# create a detached screen session running bash with the name from above
screen -dmS "$session_name" bash


# create a background process that dumps the current screen content to a file for the session so long as the screen exists
(while screen -list | grep -q "$session_name"; do screen -S "$session_name" -X hardcopy "$logfile" >/dev/null 2>&1; sleep 1; done) &


# create an arg passthrough for rsync and set up the command that we're going to run
args=$(printf '%s ' "$@")
source=$(printf '%s' "${@:(-2):1}")
target=$(printf '%s' "${@: -1}")
commands=$(printf 'rsync --info=progress2 --no-inc-recursive %s; sleep 10; exit;' "$args")

# if the user sends the --remove-source-files rsync option, then we'll send a command that cleans up the leftover empty directories.
if [[ $args == *"--remove-source-files"* ]]; then
  commands=$(printf 'rsync --info=progress2 --no-inc-recursive %s; find %s -empty -type d -delete; sleep 10; exit;' "$args" "$source")
fi


# cd the screen session to current working dir, so that the relative paths we pass work properly
screen -S "$session_name" -X stuff "cd $PWD"`echo -ne '\015'`

# clear the screen for slightly more legible output in the session log file
screen -S "$session_name" -X stuff "clear"`echo -ne '\015'`

# push the rsync command to the screen session
screen -S "$session_name" -X stuff "$commands"`echo -ne '\015'`

# tell the user where to watch the progress output
printf 'Status can be viewed by watching %s\n' "$logfile"
