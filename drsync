#!/usr/bin/env bash

# create a variable that contains the entire set of arguments passed as a single line and preserving escape characters
args=""
for arg in "$@"
do
  args+=$(printf '%q ' "$arg")
done

# create a hidden logfile directory if there isn't already one
if [ ! -d "$HOME/.drsync_transfers" ] 
then
   mkdir "$HOME/.drsync_transfers"
fi

# figure out a valid transfer number and assign a new session name
prev_transfer_num=`ls "$HOME/.drsync_transfers" | sort --version-sort | grep "drsync" | tail -1 | grep -o "[1-9][0-9]*"`
transfer_num=$((prev_transfer_num+1))
session_name=`printf 'drsync.%06g' "$transfer_num"`
logfile="$HOME/.drsync_transfers/$session_name"

# log the command that was used
printf 'drsync %s' "$args" > "$logfile.cmd"

# do a dry run of the rsync job and log the file list
bash -c "rsync -v --dry-run $args > $logfile.filelist"
bash -c "awk -v n=1 -v s='<===================== VERIFY INCREMENTAL FILE LIST =====================>' 'NR == n {print s} {print}' $logfile.filelist | less -S"

# touch logfile to reserve number in case another job launches before logging starts
touch "$logfile.status"

# parse args to figure out if the transfer is using any --include-from text files, so that we can preserve them alongside the logs
include_from_used='No'
if [[ $args == *"--include-from"* ]]; then
  for var in "$@"
  do
    if [[ $var == *"--include-from"* ]]; then
      include_from=$(echo "$var" | sed 's/--include-from=//')
    fi
  done
  cat "$include_from" > "$logfile.includefrom"
  include_from_used='Yes'
  # modify the args passed to screen session to cleanup the include file.
  args=`printf '%s; rm %s' "$args" "$include_from"`
fi

# parse args to figure out if the transfer is using any --include-from text files, so that we can preserve them alongside the logs
files_from_used='No'
if [[ $args == *"--files-from"* ]]; then
  for var in "$@"
  do
    if [[ $var == *"--files-from"* ]]; then
      files_from=$(echo "$var" | sed 's/--files-from=//')
    fi
  done
  cat "$files_from" > "$logfile.filesfrom"
  files_from_used='Yes'
  # modify the args passed to screen session to cleanup the include file.
  args=`printf '%s; rm %s' "$args" "$files_from"`
fi

# parse args to figure out which args are source directories.
sources=()
sources_str=""
for var in ${@:1:$#-1}
do
  [[ $var =~ ^-.* ]] && continue
    sources+=("$var")
    sources_str="$sources_str$var\n"
done

# parse for target
target="${@: -1}"

# if we passed a --remove-source-files, then modify the args to include a bunch of find and delete empties
cleanup='No'
if [[ $args == *"--remove-source-files"* ]]; then
  source_parents=()
  for source in "${sources[@]}"
  do
    source_parent=$(echo "$source" | grep -o '.*/')
    echo "$source_parent"
    source_parents+=("$source_parent")
  done
  uniq_source_parents=($(for p in "${source_parents[@]}"; do echo "${p}"; done | sort -u))
  for p in "$uniq_source_parents"
  do
    args=`printf '%s; find %s -empty -type d -delete' "$args" "$p"`
  done
  echo 'Empty directories left in source directories will be cleaned after rsync is complete.'
  cleanup='Yes'
fi

printf "$sources_str" > "$logfile.sources"
printf "$target" > "$logfile.target"

read  -n 1 -p "Proceed with transfer? (Y/n):" transfer_approved
if [ "$transfer_approved" == 'n' ] || [ "$transfer_approved" == 'N' ]; then
  printf '\nTransfer aborted.\n'
  echo 'Transfer aborted.' >> "$logfile.status"
else
  # launch the screen session with the arguments we passed
  screen -dmS "$session_name" bash -c "echo Transfer started: `date`; echo pwd: $PWD; echo Remove and clean sources: $cleanup; echo Use --include-from option: $include_from_used; echo Use --files-from option: $files_from_used; rsync --no-inc-recursive --info=progress2 $args; echo Transfer finished: `date` ; sleep 3;"

  # create a background process that dumps the current screen content to a file for the session so long as the screen exists
  (while screen -list | grep -q "$session_name"; do screen -S "$session_name" -X hardcopy "$logfile.status" >/dev/null 2>&1; sleep 1; done) &
fi

# tell the user where to watch the progress output
printf 'Status can be viewed by watching %s\n' "$logfile.status"
