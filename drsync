#!/usr/bin/env bash
# exit if we hit any error
#set -e

# create a variable that contains the entire set of arguments passed as a single line
args=$(printf '%s' "$*")

# create a hidden logfile directory if there isn't already one
if [ ! -d "$HOME/.drsync_transfers" ] 
then
   mkdir "$HOME/.drsync_transfers"
fi

# figure out a valid transfer number and assign a new session name
prev_transfer_num=`ls "$HOME/.drsync_transfers" | sort --version-sort | grep "drsync" | tail -1 | grep -o "[1-9][0-9]*"`
transfer_num=$((prev_transfer_num+1))
session_name=`printf 'drsync.%06g' "$transfer_num"`
logfile="$HOME/.drsync_transfers/$session_name"

# touch logfile to reserve number in case another job launches before logging starts
touch "$logfile.log"

# parse args to figure out if the transfer is using any --include-from text files, so that we can preserve them alongside the logs
include_from_used='No'
if [[ $args == *"--include-from"* ]]; then
  for var in "$@"
  do
    if [[ $var == *"--include-from"* ]]; then
      include_from=$(echo "$var" | sed 's/--include-from=//')
    fi
  done
  cp "$include_from" "$logfile.includefrom"
  include_from_used='Yes'
fi


# parse args to figure out which args are source directories.
sources=()
for var in ${@:1:$#-1}
do
  [[ $var =~ ^-.* ]] && continue
     sources+=("$var")
done

# parse for target
target="${@: -1}"

# if we passed a --remove-source-files, then modify the args to include a bunch of find and delete empties
cleanup='No'
if [[ $args == *"--remove-source-files"* ]]; then
  for source in "${sources[@]}"
  do
    args=`printf '%s; find %s -empty -type d -delete' "$args" "$source"`
  done
  echo 'Empty directories left in source directories will be cleaned after rsync is complete.'
  cleanup='Yes'
fi

# launch the screen session with the arguments we passed
screen -dmS "$session_name" bash -c "cd $PWD; echo pwd: $PWD; echo Sources: ${sources[@]}; echo Target: $target; echo Removed and cleaned sources: $cleanup; rsync --info=progress2 $args; sleep 3;"

# create a background process that dumps the current screen content to a file for the session so long as the screen exists
(while screen -list | grep -q "$session_name"; do screen -S "$session_name" -X hardcopy "$logfile.log" >/dev/null 2>&1; sleep 1; done) &

# tell the user where to watch the progress output
printf 'Status can be viewed by watching %s\n' "$logfile."
